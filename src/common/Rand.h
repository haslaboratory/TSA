#pragma once

#include <cassert>
#include <cstdint>
#include <random>
#include <string>

#include "common/Utils.h"

template <class IntType = uint64_t, class RealType = double>
class zipf_table_distribution {
public:
    typedef IntType result_type;

    static_assert(std::numeric_limits<IntType>::is_integer, "");
    static_assert(!std::numeric_limits<RealType>::is_integer, "");

    /// zipf_table_distribution(N, s)
    /// Zipf distribution for `N` items, in the range `[1,N]` inclusive.
    /// The distribution follows the power-law 1/n^s with exponent `s`.
    /// This uses a table-lookup, and thus provides values more
    /// quickly than zipf_distribution. However, the table can take
    /// up a considerable amount of RAM, and initializing this table
    /// can consume significant time.
    zipf_table_distribution(const IntType n, const RealType q = 1.0)
        : _n(init(n, q)), _q(q), _dist(_pdf.begin(), _pdf.end()) {}
    void reset() {}

    IntType operator()(std::mt19937_64 &rng) { return _dist(rng); }

    /// Returns the parameter the distribution was constructed with.
    RealType s() const { return _q; }
    /// Returns the minimum value potentially generated by the distribution.
    result_type min() const { return 1; }
    /// Returns the maximum value potentially generated by the distribution.
    result_type max() const { return _n; }

private:
    std::vector<RealType> _pdf;                ///< Prob. distribution
    IntType _n;                                ///< Number of elements
    RealType _q;                               ///< Exponent
    std::discrete_distribution<IntType> _dist; ///< Draw generator

    /** Initialize the probability mass function */
    IntType init(const IntType n, const RealType q) {
        _pdf.reserve(n + 1);
        _pdf.emplace_back(0.0);
        for (IntType i = 1; i <= n; i++)
            _pdf.emplace_back(std::pow((double)i, -q));
        return n;
    }
};

// Return max or min value if the double is outside of type's range
template <typename T> T narrow_cast(double i) {
    if (i > static_cast<double>(std::numeric_limits<T>::max())) {
        return std::numeric_limits<T>::max();
    } else if (i < static_cast<double>(std::numeric_limits<T>::min())) {
        return std::numeric_limits<T>::min();
    }
    return static_cast<T>(i);
}

// sampling object id and object size from a Zipf-like distribution
// (aka the independent reference model (IRM))
//
// Multiple objects with similar rates are grouped together for more efficient
// sampling. Two level sampling process: first skewed sample to select the rate,
// then uniform sample within rate to select object.
class FastDiscreteDistribution {
public:
    FastDiscreteDistribution() {}
    // This distribution expects a list of buckets (sizes) and weights (probs).
    // All objects in a bucket will be selected with roughly the same
    // probability, and each bucket is drawn approximately proporionally to its
    // weight.
    // @param left denotes the minimum index the distribution can generate
    // @param right denotes the maximum index the distribution can generate
    // @param sizes and @param probs work as described above
    // @param numBuckets controls the number of equal weight buckets used to
    // approximate the distribution.  A higher number results in a distribution
    // closer to the input distribution from sizes and probs.
    FastDiscreteDistribution(size_t left, size_t right,
                             std::vector<size_t> sizes,
                             std::vector<double> probs,
                             size_t numBuckets = 2048)
        : leftOffset_(left), rightOffset_(right) {
        double totalWeight = std::accumulate(probs.begin(), probs.end(), 0.0);
        double totalObjects = std::accumulate(sizes.begin(), sizes.end(), 0.0);
        bucketWeight_ = totalWeight / numBuckets;
        double weightSeen = 0.0;
        size_t objectsSeen = 0;
        scalingFactor_ = (right - left) / totalObjects;
        bucketOffsets_.push_back(0);
        size_t i = 0;
        std::vector<uint64_t> buckets;
        // Divide the input distribution into numBuckets of equal weight.
        // The approximation is that objects in a bucket have equal weight.
        // Since we have equal weight buckets and (roughly) equal weight objects
        // we can sample in constant time by drawing 2 Uniform r.v.'s.
        while (i < probs.size()) {
            if (weightSeen + probs[i] >= bucketWeight_) {
                // interpolate, update bucket, reset
                double bucketPct = (bucketWeight_ - weightSeen) / probs[i];
                objectsSeen += narrow_cast<size_t>(bucketPct * sizes[i]);
                objectsSeen = std::max(1UL, objectsSeen);
                sizes[i] -= narrow_cast<size_t>(bucketPct * sizes[i]);
                probs[i] -= bucketPct * probs[i];
                buckets.push_back(
                    static_cast<uint64_t>(objectsSeen * scalingFactor_));
                if (bucketOffsets_.size() > 0) {
                    bucketOffsets_.push_back(bucketOffsets_.back() +
                                             objectsSeen);
                }
                weightSeen = 0.0;
                objectsSeen = 0;
            } else {
                weightSeen += probs[i];
                objectsSeen += sizes[i];
                i++;
            }
        }
        bucketDistribution_ =
            std::uniform_int_distribution<uint64_t>(0, buckets.size() - 1);
        for (auto it = buckets.begin(); it != buckets.end(); it++) {
            insideBucketDistributions_.emplace_back(0, (*it) - 1);
        }

        uint64_t real_cnt = 0;
        for (size_t i = 0; i < buckets.size(); i++) {
            real_cnt += buckets[i];
        }
        if (unlikely(real_cnt > right - left)) {
            printf("real_cnt: %lu, right - left: %lu\n", real_cnt, right - left);
            exit(-1);
        }
    }

    FastDiscreteDistribution(FastDiscreteDistribution &&) = default;
    FastDiscreteDistribution &operator=(FastDiscreteDistribution &&) = default;
    FastDiscreteDistribution(const FastDiscreteDistribution &) = default;
    FastDiscreteDistribution &
    operator=(const FastDiscreteDistribution &) = default;

    size_t operator()(std::mt19937_64 &gen) {
        size_t bucket = bucketDistribution_(gen);
        size_t objectInBucket =
            narrow_cast<size_t>(insideBucketDistributions_[bucket](gen));
        auto ret =
            narrow_cast<size_t>((bucketOffsets_[bucket] + objectInBucket)) +
            leftOffset_;
        
        if (unlikely(ret > rightOffset_)) {
            printf("ret: %lu, rightOffset_: %lu\n", ret, rightOffset_);
            exit(-1);
        }
        assert(ret <= rightOffset_);
        assert(ret >= leftOffset_);
        return ret;
    }

    void summarize() const {
        size_t count(0);
        printf("Bucket Weight: %lf\n", bucketWeight_);
        printf("Buckets:\n");
        for (auto offset : bucketOffsets_) {
            printf("%ld: %ld\n", count, offset);
            count++;
        }
    }

private:
    std::vector<uint64_t> bucketOffsets_{};
    const size_t leftOffset_{};
    const size_t rightOffset_{};
    double scalingFactor_{};
    double bucketWeight_{};
    std::uniform_int_distribution<uint64_t> bucketDistribution_{};
    std::vector<std::uniform_int_distribution<uint64_t>>
        insideBucketDistributions_{};
};

static inline uint32_t FastRand(uint64_t *seed) {
    *seed = *seed * 1103515245 + 12345;
    return (uint32_t)(*seed >> 32);
}

class FastRandom {
public:
    FastRandom(uint64_t sed) : seed(0) { SetSeed0(sed); }

    FastRandom() : seed(0) { SetSeed0(seed); }

    inline uint64_t Next() {
        return ((uint64_t)Next(32) << 32) + Next(32);
    }

    inline uint32_t NextU32() { return Next(32); }

    inline uint16_t NextU16() { return Next(16); }

    /** [0.0, 1.0) */
    inline double NextUniform() {
        return (((uint64_t)Next(26) << 27) + Next(27)) /
               (double)(1L << 53);
    }

    inline char NextChar() { return Next(8) % 256; }

    inline std::string NextString(size_t len) {
        std::string s(len, 0);
        for (size_t i = 0; i < len; i++)
            s[i] = NextChar();
        return s;
    }

    inline uint64_t GetSeed() { return seed; }

    inline void SetSeed(uint64_t sed) { this->seed = sed; }

    inline void SetSeed0(uint64_t sed) {
        this->seed = (sed ^ 0x5DEECE66DL) & ((1L << 48) - 1);
    }

    inline uint64_t RandNumber(int min, int max) {
        return CheckBetweenInclusive(
            (uint64_t)(NextUniform() * (max - min + 1) + min), min, max);
    }

    inline uint64_t CheckBetweenInclusive(uint64_t v, uint64_t min,
                                          uint64_t max) {
        assert(v >= min);
        assert(v <= max);
        return v;
    }

private:
    inline uint64_t Next(unsigned int bits) {
        seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);
        return (uint64_t)(seed >> (48 - bits));
    }

    uint64_t seed;
};

class ZipfBucketRandom {
public:
    ZipfBucketRandom() = delete;
    ZipfBucketRandom(uint64_t num, double alpha, uint64_t bucket_num)
        : z_num_(num), z_alpha_(alpha), bucket_num_(bucket_num) {
        zipf_ = new zipf_table_distribution<uint64_t, double>(z_num_, z_alpha_);
        uniform_ = new std::uniform_int_distribution<uint64_t>(0, bucket_num_);
    }

    virtual ~ZipfBucketRandom() {
        if (zipf_ != nullptr) {
            delete zipf_;
            zipf_ = nullptr;
        }
        if (uniform_ != nullptr) {
            delete uniform_;
            uniform_ = nullptr;
        }
    }

    uint64_t operator()(std::mt19937_64 &rng) {
        uint64_t bucket = (*uniform_)(rng);
        uint64_t index = (*zipf_)(rng) -1;
        return index * bucket_num_ + bucket;
    }

private:
    zipf_table_distribution<uint64_t, double> *zipf_{nullptr};
    uint64_t z_num_;
    double z_alpha_;
    std::uniform_int_distribution<uint64_t> *uniform_{nullptr};
    uint64_t bucket_num_;
};

class SampleBucketRandom {
public:
    SampleBucketRandom() = delete;
    SampleBucketRandom(std::vector<double> weights, std::vector<uint64_t> nums)
        : nums_(nums)
    {
        pdf_.reserve(nums_.size());
        pdf_.emplace_back(0.0);
        double total = std::accumulate(weights.begin(), weights.end(), 0.0);
        for (auto it = weights.begin(); it!= weights.end(); it++) {
            pdf_.emplace_back((*it) / total);
        }
        outer_dist_ = std::discrete_distribution<uint64_t>(pdf_.begin(), pdf_.end());
        inner_dist_ = std::uniform_int_distribution<uint64_t>(0, UINT64_MAX);
        
        starts_.resize(pdf_.size());
        starts_[0] = 0;
        for (uint64_t i = 1; i < pdf_.size(); i++) {
            starts_[i] = starts_[i - 1] + nums_[i - 1];
        }
    }

    uint64_t operator()(std::mt19937_64 &gen) {
        uint64_t bucket = outer_dist_(gen) - 1;
        assert(bucket < pdf_.size());
        uint64_t inner_idx = inner_dist_(gen) % nums_[bucket];
        assert(inner_idx < nums_[bucket]);

        return starts_[bucket] + inner_idx;
    }
private:
    std::vector<double> pdf_;
    std::discrete_distribution<uint64_t> outer_dist_;
    std::uniform_int_distribution<uint64_t> inner_dist_;
    std::vector<uint64_t> starts_;
    std::vector<uint64_t> nums_;
};

inline uint32_t rand32(void) {
    static thread_local FastRandom rand = FastRandom(rdtsc());

    return rand.NextU32();
}

inline uint64_t rand64(void) {
    static thread_local FastRandom rand = FastRandom(rdtsc());

    return rand.Next();
}